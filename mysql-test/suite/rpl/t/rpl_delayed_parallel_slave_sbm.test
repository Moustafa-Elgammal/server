#
#   This test ensures that a delayed, parallel replica updates
# Seconds_Behind_Master using the convention established for serial replicas.
# Where a non-delayed, parallel replica will update Seconds_Behind_Master at
# transaction commit time; this strategy can reflect very large values for
# delayed slaves, especially for infrequent events. In particular, these large
# values are due to the calculation including both the value for master_delay
# and the potentially long gap since the previous commit.
#
# Note: Despite using the same programmatic structure for a serial replica, a
# key difference in the Seconds_Behind_Master behavior on a delayed, parallel
# replica is that the value will be reflective of the transactions queued to
# be executed, rather than actively executing. Effectively, this means the
# value will seem more recent than the true state of the replica for workers
# with long queues. This will be fixed after MDEV-17516.
#
# References:
#   MDEV-29639: Seconds_Behind_Master is incorrect for Delayed, Parallel
#               Replicas
#
--source include/master-slave.inc
--source include/have_innodb.inc

--connection master
create table t1 (a int) engine=innodb;
--source include/sync_slave_sql_with_master.inc

--connection slave
--source include/stop_slave.inc
--let $master_delay= 3
--eval change master to master_delay=$master_delay, master_use_gtid=Slave_Pos
--source include/start_slave.inc

--connection slave
LOCK TABLE t1 WRITE;

--connection master
insert into t1 values (1);

--connection slave
--echo # Waiting for first transaction to start executing on slave..
--let $wait_condition= SELECT count(*) FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock%';
--source include/wait_condition.inc
--let $sbm_trx1_wait= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)

--connection master
insert into t1 values (2);
--source include/save_master_gtid.inc

--connection slave

--echo # Waiting for second transaction to delay on slave..
--let $wait_condition= SELECT count(*) FROM information_schema.processlist WHERE state LIKE 'Waiting until MASTER_DELAY seconds after master executed event';
--source include/wait_condition.inc
--let $sbm_trx2_wait= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)

if (`SELECT $sbm_trx2_wait > 1`)
{
    --die Seconds_Behind_Master should have updated when slave received second transaction
}

--echo # Sleep to bump SBM > 0
sleep 1;

--let $sbm_trx2_during_delay= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)
if (`SELECT $sbm_trx2_during_delay > $master_delay OR $sbm_trx2_during_delay = 0`)
{
    --die Seconds_Behind_Master should grow while delayed by SQL Delay
}

--connection slave
--echo # Waiting for second transaction to begin executing..
--let $wait_condition= SELECT count(*) FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to start commit%';
--source include/wait_condition.inc

--echo # Sleep to bump SBM > SQL_Delay
sleep 1;

--let $sbm_trx2_long_running= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)
if (`SELECT $sbm_trx2_long_running <= $master_delay`)
{
    --die Seconds_Behind_Master should grow beyond SQL_Delay
}

--echo # Unlock tables to allow both transactions to complete on slave
UNLOCK TABLES;
--source include/sync_with_master_gtid.inc

--let $sbm_idle= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)

if (`SELECT $sbm_idle > 0`)
{
    --die Seconds_Behind_Master should be 0 when idle
}

--echo #
--echo # Cleanup

--connection slave
--echo # Reset master_delay
--source include/stop_slave.inc
--eval CHANGE MASTER TO master_delay=0, master_use_gtid=No
--source include/start_slave.inc

--connection master
DROP TABLE t1;
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc

--source include/rpl_end.inc

--echo # End of rpl_delayed_parallel_slave_sbm.test
