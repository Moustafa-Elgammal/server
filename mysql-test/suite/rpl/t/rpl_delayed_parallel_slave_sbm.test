#
#   This test ensures that after a delayed parallel slave has idled, i.e.
# executed everything in its relay log, the next event group that the SQL
# thread reads from the relay log will immediately be used in the
# Seconds_Behind_Master. In particular, it ensures that the calculation for
# Seconds_Behind_Master is based on the timestamp of the new transaction,
# rather than the last committed transaction.
#
# References:
#   MDEV-29639: Seconds_Behind_Master is incorrect for Delayed, Parallel
#               Replicas
#

--source include/master-slave.inc

--connection master
create table t1 (a int);
--source include/sync_slave_sql_with_master.inc

--connection slave
--source include/stop_slave.inc
--let $master_delay= 3
--eval change master to master_delay=$master_delay, master_use_gtid=Slave_Pos
--let $old_slave_threads= `SELECT @@GLOBAL.slave_parallel_threads`
set @@GLOBAL.slave_parallel_threads=2;
--source include/start_slave.inc

--connection slave
LOCK TABLES t1 WRITE;

--connection master
--echo # Sleep 1 to allow a buffer between events for SBM check
sleep 1;
--let $ts_trx_before_ins= `SELECT UNIX_TIMESTAMP()`
--let insert_ctr= 0
--eval insert into t1 values ($insert_ctr)
--inc $insert_ctr
--source include/save_master_gtid.inc

--connection slave

--echo # Waiting for transaction to arrive on slave and start delaying..
--let $wait_condition= SELECT count(*) FROM information_schema.processlist WHERE state LIKE 'Waiting until MASTER_DELAY seconds after master executed event';
--source include/wait_condition.inc

--echo # Validating SBM resets..
--let $cmpv= `SELECT UNIX_TIMESTAMP()- $ts_trx_before_ins`
--let $sbm_trx1_arrive= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)
if (`SELECT $sbm_trx1_arrive > $cmpv`)
{
    #
    #
    # Negating rli->sql_thread_caught_up for all events will fail here because
    # other events will negate stcu before the insert arrives, and stcu uses
    # the timestamp of the last committed event (leading to the large gap)
    #
    #
    --echo # SBM was $sbm_trx1_arrive yet shouldn't have been larger than $cmpv
    --die Seconds_Behind_Master should reset after idling
}
--echo # ..done

--connection slave
UNLOCK TABLES;
--source include/sync_with_master_gtid.inc

--echo #
--echo # Pt 2) Ensure later events don't update SBM if SQL thread doesn't idle

--connection slave
--source include/stop_slave_io.inc

--connection master

--echo # Sleep 1 to allow a buffer between events for SBM check
sleep 1;
--let $ts_trxpt2_before_ins= `SELECT UNIX_TIMESTAMP()`
--eval insert into t1 values ($insert_ctr)
--let $mpos= `SELECT @@GLOBAL.gtid_binlog_pos`
--echo # binlog pos is $mpos
--inc $insert_ctr
--echo # Sleep 3 to create gap between events
sleep 3;
--eval insert into t1 values ($insert_ctr)
--let $mpos= `SELECT @@GLOBAL.gtid_binlog_pos`
--echo # binlog pos is $mpos
--inc $insert_ctr
--let $ts_trx_after_ins= `SELECT UNIX_TIMESTAMP()`

--connection slave
LOCK TABLES t1 WRITE;

START SLAVE IO_THREAD;

--echo # Wait for first transaction to start
--let $wait_condition= SELECT count(*) FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock%';
--source include/wait_condition.inc

--echo # Validating SBM doesn't use the second transaction because SQL thread shouldn't have gone idle..
--let $sbm_after_trx_no_idle= query_get_value(SHOW SLAVE STATUS, Seconds_Behind_Master, 1)
--let $timestamp_trxpt2_arrive= `SELECT UNIX_TIMESTAMP()`
if (`SELECT $sbm_after_trx_no_idle <= $timestamp_trxpt2_arrive - $ts_trx_after_ins`)
{
    #
    #
    # adding conditions of not updating stcu on certain events (e.g. fde) will
    # fail here or the next one, depending on which events are blacklisted from
    # updating stcu
    #
    #
    --echo # SBM was $sbm_after_trx_no_idle
    --die Seconds_Behind_Master should not have used second transaction timestamp
}
--let $cmpv= `SELECT ($timestamp_trxpt2_arrive - $ts_trxpt2_before_ins)`
--echo # ..and that SBM wasn't calculated using prior committed transactions
if (`SELECT $sbm_after_trx_no_idle > $cmpv`)
{
    --echo # SBM was $sbm_after_trx_no_idle yet shouldn't have been larger than $cmpv
    --die Seconds_Behind_Master calculation should not have used prior committed transaction
}
--echo # ..done

#
#
# Updating stcu only when lmt is updated passes
#
#


--connection slave
UNLOCK TABLES;

--echo #
--echo # Cleanup

--echo # Reset master_delay
--source include/stop_slave.inc
--eval CHANGE MASTER TO master_delay=0
--eval set @@GLOBAL.slave_parallel_threads=$old_slave_threads
--source include/start_slave.inc

--connection master
DROP TABLE t1;
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc

--source include/rpl_end.inc

--echo # End of rpl_delayed_parallel_slave_sbm.test
